<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 手势控制粒子系统</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* 摄像头预览 (左下角，镜像翻转) */
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            /* 镜像 */
        }

        /* 加载提示 */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 20;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>

    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
</head>

<body>

    <div id="loader">正在启动摄像头与AI模型...</div>
    <div id="video-container">
        <video id="input-video"></video>
    </div>
    <div id="canvas-container"></div>

    <script>
        // --- 1. Three.js 场景初始化 ---
        const scene = new THREE.Scene();
        // 添加一点环境雾
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 2.0;

        // --- 2. 粒子系统核心逻辑 ---
        const particleCount = 15000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const targetPositions = new Float32Array(particleCount * 3); // 存储目标形状的位置

        // 初始化位置 (随机分布)
        for (let i = 0; i < particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // 材质
        const material = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.15,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. 形状生成数学函数 ---

        function getPointOnSphere(idx) {
            const phi = Math.acos(-1 + (2 * idx) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            const r = 10;
            return {
                x: r * Math.cos(theta) * Math.sin(phi),
                y: r * Math.sin(theta) * Math.sin(phi),
                z: r * Math.cos(phi)
            };
        }

        function getPointOnHeart(idx) {
            // 心形参数方程
            const t = (idx / particleCount) * Math.PI * 2;
            // 随机分布在体积内
            const r = 1.2;
            // 使用更复杂的3D心形公式
            let x, y, z;
            // 简单的参数分布
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;

            // 此处使用特定形状映射，为了简单，我们用随机采样+数学修正
            // 这里使用一个经典的心形公式
            const beta = Math.random() * Math.PI * 2;
            const alpha = Math.random() * Math.PI;

            x = 16 * Math.pow(Math.sin(beta), 3);
            y = 13 * Math.cos(beta) - 5 * Math.cos(2 * beta) - 2 * Math.cos(3 * beta) - Math.cos(4 * beta);
            z = 5 * Math.cos(alpha) * Math.sin(beta); // 给予Z轴厚度

            return { x: x * 0.5, y: y * 0.5, z: z * 0.5 };
        }

        function getPointOnSaturn(idx) {
            const ratio = 0.7; // 70% 粒子在星球，30% 在环
            const isPlanet = Math.random() < ratio;

            if (isPlanet) {
                const r = 6;
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.sqrt(particleCount * Math.PI) * phi;
                return {
                    x: r * Math.cos(theta) * Math.sin(phi),
                    y: r * Math.sin(theta) * Math.sin(phi),
                    z: r * Math.cos(phi)
                };
            } else {
                // 环
                const angle = Math.random() * Math.PI * 2;
                const dist = 9 + Math.random() * 5;
                return {
                    x: Math.cos(angle) * dist,
                    y: (Math.random() - 0.5) * 0.5, // 扁平
                    z: Math.sin(angle) * dist
                };
            }
        }

        function getPointOnDNA(idx) {
            const t = (idx / particleCount) * 30; // 长度
            const radius = 5;
            // 双螺旋
            const branch = idx % 2 === 0 ? 1 : -1;

            return {
                x: Math.cos(t) * radius + (Math.random() - 0.5),
                y: (idx / particleCount - 0.5) * 40, // 高度拉伸
                z: Math.sin(t) * radius + branch * 2 // 分开两条链
            };
        }

        function getPointExplosion(idx) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = Math.random() * 30; // 扩散半径
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        // --- 4. 状态管理与 UI ---
        const params = {
            shape: 'Saturn',
            color: '#00ffff',
            handControl: true, // 是否开启手势
            interactionStrength: 1.0 // 缩放系数
        };

        function updateTargetShape(shapeName) {
            let generator;
            switch (shapeName) {
                case 'Heart': generator = getPointOnHeart; break;
                case 'Saturn': generator = getPointOnSaturn; break;
                case 'DNA': generator = getPointOnDNA; break;
                case 'Fireworks': generator = getPointExplosion; break;
                default: generator = getPointOnSphere; break;
            }

            for (let i = 0; i < particleCount; i++) {
                const p = generator(i);
                targetPositions[i * 3] = p.x;
                targetPositions[i * 3 + 1] = p.y;
                targetPositions[i * 3 + 2] = p.z;
            }
        }

        // 初始化第一次形状
        updateTargetShape(params.shape);

        // GUI 设置
        const gui = new lil.GUI({ title: '控制面板' });
        gui.add(params, 'shape', ['Heart', 'Saturn', 'DNA', 'Fireworks']).name('模型形状').onChange(updateTargetShape);
        gui.addColor(params, 'color').name('粒子颜色').onChange(v => material.color.set(v));
        gui.add(params, 'interactionStrength', 0.1, 3.0).name('缩放基数').listen(); // listen 允许代码改变UI

        // --- 5. MediaPipe Hands 整合 ---
        const videoElement = document.getElementById('input-video');
        let handDistance = 1.0; // 默认为 1 (正常大小)
        let isHandDetected = false;

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 获取大拇指指尖 (4) 和 食指指尖 (8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                // 计算欧几里得距离 (屏幕坐标系，大致范围 0 - 1)
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // 映射距离到缩放系数
                // 捏合时 distance 约为 0.05，张开时约为 0.2-0.3
                // 我们希望：捏合 -> 0.2倍大小，张开 -> 2.0倍大小
                // 将 0.02 - 0.25 映射到 0.2 - 2.5
                const minInput = 0.02;
