<!DOCTYPE html>
<html lang="zh">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI 手势控制粒子系统</title>
    <style>
        body {
            margin: 0;
            overflow: hidden;
            background-color: #000;
            font-family: 'Segoe UI', sans-serif;
        }

        #canvas-container {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
        }

        /* 摄像头预览 (左下角，镜像翻转) */
        #video-container {
            position: absolute;
            bottom: 20px;
            left: 20px;
            width: 200px;
            height: 150px;
            border-radius: 12px;
            overflow: hidden;
            border: 2px solid rgba(255, 255, 255, 0.2);
            z-index: 10;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
        }

        #input-video {
            width: 100%;
            height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            /* 镜像 */
        }

        /* 加载提示 */
        #loader {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: white;
            font-size: 24px;
            z-index: 20;
            pointer-events: none;
            transition: opacity 0.5s;
        }
    </style>

    <script src="https://unpkg.com/three@0.132.2/build/three.min.js"></script>
    <script src="https://unpkg.com/three@0.132.2/examples/js/controls/OrbitControls.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/lil-gui@0.17.0/dist/lil-gui.umd.min.js"></script>
</head>

<body>

    <div id="loader">正在启动摄像头与AI模型...</div>
    <div id="video-container">
        <video id="input-video"></video>
    </div>
    <div id="canvas-container"></div>

    <script>
        // --- 1. Three.js 场景初始化 ---
        const scene = new THREE.Scene();
        // 添加一点环境雾
        scene.fog = new THREE.FogExp2(0x000000, 0.002);

        const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.z = 30;

        const renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(window.devicePixelRatio);
        document.getElementById('canvas-container').appendChild(renderer.domElement);

        const controls = new THREE.OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true;
        controls.autoRotate = true;
        controls.autoRotateSpeed = 2.0;

        // --- 2. 粒子系统核心逻辑 ---
        const particleCount = 15000;
        const geometry = new THREE.BufferGeometry();
        const positions = new Float32Array(particleCount * 3);
        const targetPositions = new Float32Array(particleCount * 3); // 存储目标形状的位置

        // 初始化位置 (随机分布)
        for (let i = 0; i < particleCount * 3; i++) {
            positions[i] = (Math.random() - 0.5) * 50;
            targetPositions[i] = positions[i];
        }

        geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));

        // 材质
        const material = new THREE.PointsMaterial({
            color: 0x00ffff,
            size: 0.15,
            transparent: true,
            opacity: 0.8,
            blending: THREE.AdditiveBlending,
            depthWrite: false
        });

        const particles = new THREE.Points(geometry, material);
        scene.add(particles);

        // --- 3. 形状生成数学函数 ---

        function getPointOnSphere(idx) {
            const phi = Math.acos(-1 + (2 * idx) / particleCount);
            const theta = Math.sqrt(particleCount * Math.PI) * phi;
            const r = 10;
            return {
                x: r * Math.cos(theta) * Math.sin(phi),
                y: r * Math.sin(theta) * Math.sin(phi),
                z: r * Math.cos(phi)
            };
        }

        function getPointOnHeart(idx) {
            // 心形参数方程
            const t = (idx / particleCount) * Math.PI * 2;
            // 随机分布在体积内
            const r = 1.2;
            // 使用更复杂的3D心形公式
            let x, y, z;
            // 简单的参数分布
            const phi = Math.random() * Math.PI * 2;
            const theta = Math.random() * Math.PI;

            // 此处使用特定形状映射，为了简单，我们用随机采样+数学修正
            // 这里使用一个经典的心形公式
            const beta = Math.random() * Math.PI * 2;
            const alpha = Math.random() * Math.PI;

            x = 16 * Math.pow(Math.sin(beta), 3);
            y = 13 * Math.cos(beta) - 5 * Math.cos(2 * beta) - 2 * Math.cos(3 * beta) - Math.cos(4 * beta);
            z = 5 * Math.cos(alpha) * Math.sin(beta); // 给予Z轴厚度

            return { x: x * 0.5, y: y * 0.5, z: z * 0.5 };
        }

        function getPointOnSaturn(idx) {
            const ratio = 0.7; // 70% 粒子在星球，30% 在环
            const isPlanet = Math.random() < ratio;

            if (isPlanet) {
                const r = 6;
                const phi = Math.acos(-1 + (2 * Math.random()));
                const theta = Math.sqrt(particleCount * Math.PI) * phi;
                return {
                    x: r * Math.cos(theta) * Math.sin(phi),
                    y: r * Math.sin(theta) * Math.sin(phi),
                    z: r * Math.cos(phi)
                };
            } else {
                // 环
                const angle = Math.random() * Math.PI * 2;
                const dist = 9 + Math.random() * 5;
                return {
                    x: Math.cos(angle) * dist,
                    y: (Math.random() - 0.5) * 0.5, // 扁平
                    z: Math.sin(angle) * dist
                };
            }
        }

        function getPointOnDNA(idx) {
            const t = (idx / particleCount) * 30; // 长度
            const radius = 5;
            // 双螺旋
            const branch = idx % 2 === 0 ? 1 : -1;

            return {
                x: Math.cos(t) * radius + (Math.random() - 0.5),
                y: (idx / particleCount - 0.5) * 40, // 高度拉伸
                z: Math.sin(t) * radius + branch * 2 // 分开两条链
            };
        }

        function getPointExplosion(idx) {
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos((Math.random() * 2) - 1);
            const r = Math.random() * 30; // 扩散半径
            return {
                x: r * Math.sin(phi) * Math.cos(theta),
                y: r * Math.sin(phi) * Math.sin(theta),
                z: r * Math.cos(phi)
            };
        }

        // --- 4. 状态管理与 UI ---
        const params = {
            shape: 'Saturn',
            color: '#00ffff',
            handControl: true, // 是否开启手势
            interactionStrength: 1.0 // 缩放系数
        };

        function updateTargetShape(shapeName) {
            let generator;
            switch (shapeName) {
                case 'Heart': generator = getPointOnHeart; break;
                case 'Saturn': generator = getPointOnSaturn; break;
                case 'DNA': generator = getPointOnDNA; break;
                case 'Fireworks': generator = getPointExplosion; break;
                default: generator = getPointOnSphere; break;
            }

            for (let i = 0; i < particleCount; i++) {
                const p = generator(i);
                targetPositions[i * 3] = p.x;
                targetPositions[i * 3 + 1] = p.y;
                targetPositions[i * 3 + 2] = p.z;
            }
        }

        // 初始化第一次形状
        updateTargetShape(params.shape);

        // GUI 设置
        const gui = new lil.GUI({ title: '控制面板' });
        gui.add(params, 'shape', ['Heart', 'Saturn', 'DNA', 'Fireworks']).name('模型形状').onChange(updateTargetShape);
        gui.addColor(params, 'color').name('粒子颜色').onChange(v => material.color.set(v));
        gui.add(params, 'interactionStrength', 0.1, 3.0).name('缩放基数').listen(); // listen 允许代码改变UI

        // --- 5. MediaPipe Hands 整合 ---
        const videoElement = document.getElementById('input-video');
        let handDistance = 1.0; // 默认为 1 (正常大小)
        let isHandDetected = false;

        const hands = new Hands({
            locateFile: (file) => {
                return `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`;
            }
        });

        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.5,
            minTrackingConfidence: 0.5
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                isHandDetected = true;
                const landmarks = results.multiHandLandmarks[0];

                // 获取大拇指指尖 (4) 和 食指指尖 (8)
                const thumbTip = landmarks[4];
                const indexTip = landmarks[8];

                // 计算欧几里得距离 (屏幕坐标系，大致范围 0 - 1)
                const distance = Math.sqrt(
                    Math.pow(thumbTip.x - indexTip.x, 2) +
                    Math.pow(thumbTip.y - indexTip.y, 2)
                );

                // 映射距离到缩放系数
                // 捏合时 distance 约为 0.05，张开时约为 0.2-0.3
                // 我们希望：捏合 -> 0.2倍大小，张开 -> 2.0倍大小
                // 将 0.02 - 0.25 映射到 0.2 - 2.5
                const minInput = 0.02;
const maxInput = 0.25;

                let normalized = (distance - minInput) / (maxInput - minInput);
                normalized = Math.max(0, Math.min(1, normalized)); // Clamp 0-1

                // 平滑处理 (简单的 Lerp)
                const targetScale = 0.3 + (normalized * 2.5);
                handDistance += (targetScale - handDistance) * 0.1; // 缓动

                // 更新 UI 显示的数值
                params.interactionStrength = parseFloat(handDistance.toFixed(2));

            } else {
                isHandDetected = false;
                // 如果没检测到手，慢慢恢复到 1.0
                handDistance += (1.0 - handDistance) * 0.05;
            }
        });

        // 启动摄像头
        const cameraUtils = new Camera(videoElement, {
            onFrame: async () => {
                await hands.send({ image: videoElement });
            },
            width: 320,
            height: 240
        });

        cameraUtils.start()
            .then(() => {
                document.getElementById('loader').style.opacity = '0';
            })
            .catch(err => {
                document.getElementById('loader').innerText = "摄像头访问失败，请确保使用HTTPS或本地环境";
            });

        // --- 6. 动画循环 ---
        const clock = new THREE.Clock();

        function animate() {
            requestAnimationFrame(animate);

            const delta = clock.getDelta();
            controls.update();

            // 粒子动画与变形逻辑
            const positionsAttribute = geometry.attributes.position;
            const currentPositions = positionsAttribute.array;

            // 根据手势计算当前的缩放/扩散系数
            // 如果开启手势控制，使用 handDistance，否则使用 1.0
            const scale = params.handControl ? handDistance : 1.0;

            for (let i = 0; i < particleCount; i++) {
                const idx = i * 3;

                // 目标位置 (基于当前选择的形状)
                let tx = targetPositions[idx];
                let ty = targetPositions[idx + 1];
                let tz = targetPositions[idx + 2];

                // 应用手势缩放
                // 我们可以让粒子直接缩放，或者基于手势增加一点随机扰动(扩散)
                tx *= scale;
                ty *= scale;
                tz *= scale;

                // 如果是烟花模式，可以加一点基于时间的旋转或漂浮
                if (params.shape === 'Fireworks') {
                    const time = Date.now() * 0.001;
                    ty -= Math.sin(time + i) * 0.05; // 简单的漂浮
                }

                // Lerp 缓动：当前位置 -> 目标位置
                // 速度系数 3.0 * delta 决定了变形的快慢
                currentPositions[idx] += (tx - currentPositions[idx]) * 3.0 * delta;
                currentPositions[idx + 1] += (ty - currentPositions[idx + 1]) * 3.0 * delta;
                currentPositions[idx + 2] += (tz - currentPositions[idx + 2]) * 3.0 * delta;
            }

            positionsAttribute.needsUpdate = true;
            renderer.render(scene, camera);
        }

        animate();

        // 窗口大小调整
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });

    </script>
</body>

</html>
